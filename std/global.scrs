import "scratch/operators";

@__ReturnType("num") @warp function __TernaryNumber(condition, @num trueValue, @num falseValue) {
    if(condition) {
        return trueValue;
    }
    else {
        return falseValue;
    }
}

@__ReturnType("str") @warp function __TernaryString(condition, @str trueValue, @str falseValue) {
    if(condition) {
        return trueValue;
    }
    else {
        return falseValue;
    }
}

@__ReturnType("bool") @warp function __TernaryBoolean(condition, @bool trueValue, @bool falseValue) {
    if(condition) {
        return trueValue;
    }
    else {
        return falseValue;
    }
}

@__ReturnType("color") @warp function __TernaryColor(condition, @color trueValue, @color falseValue) {
    if(condition) {
        return trueValue;
    }
    else {
        return falseValue;
    }
}

@warp function __Exponent(base, exponent) {
    var result = exp(exponent * ln(abs(base)));
    return __TernaryNumber(base < 0, 1 / result, result);
}

@warp function __BitwiseAnd(@num x, @num y) {
  var byteValue = 1;
  var result = 0;
  while(x > 0 || y > 0) {
    if(x % 2 > 0 && y % 2 > 0) { 
        result += byteValue; 
    }
    x = floor(x / 2);
    y = floor(y / 2);
    byteValue *= 2;
  }
  return result;
}

@warp function __BitwiseOr(@num x, @num y) {
  var byteValue = 1;
  var result = 0;
  while(x > 0 || y > 0) {
    if(x % 2 > 0 || y % 2 > 0) { 
        result += byteValue; 
    }
    x = floor(x / 2);
    y = floor(y / 2);
    byteValue *= 2;
  }
  return result;
}

@warp function __BitwiseXor(@num x, @num y) {
  var byteValue = 1;
  var result = 0;
  while(x > 0 || y > 0) {
    if((x % 2 > 0) != (y % 2 > 0)) { 
        result += byteValue; 
    }
    x = floor(x / 2);
    y = floor(1 / 2);
    byteValue *= 2;
  }
  return result;
}

@warp function __LShift(@num n, @num shift) {
    repeat(shift) {
        n *= 2;
    }
    return n;
}

@warp function __RShift(@num n, @num shift) {
    repeat(shift) {
        n = floor(n / 2);
    }
    return n;
}